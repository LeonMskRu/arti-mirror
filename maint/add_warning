#!/usr/bin/env python3

from __future__ import annotations

import argparse
import re
import subprocess
import sys
from contextlib import suppress
from pathlib import Path
from typing import TextIO

# ---------- actual list of lints to apply (or disapply) ----------

# NOTE: We should NEVER have a `deny` for a built-in rustc lint.
# It's okay to deny clippy lints, but if we deny rustc lints,
# a future version of the compiler might refuse to build our code
# entirely.

WANT_LINTS: list[str] = [
    "#![allow(renamed_and_removed_lints)] // @@REMOVE_WHEN(ci_arti_stable)",
    "#![allow(unknown_lints)] // @@REMOVE_WHEN(ci_arti_nightly)",
    "#![warn(missing_docs)]",
    "#![warn(noop_method_call)]",
    "#![warn(unreachable_pub)]",
    "#![warn(clippy::all)]",
    "#![deny(clippy::await_holding_lock)]",
    "#![deny(clippy::cargo_common_metadata)]",
    "#![deny(clippy::cast_lossless)]",
    "#![deny(clippy::checked_conversions)]",
    "#![warn(clippy::cognitive_complexity)]",
    "#![deny(clippy::debug_assert_with_mut_call)]",
    "#![deny(clippy::exhaustive_enums)]",
    "#![deny(clippy::exhaustive_structs)]",
    "#![deny(clippy::expl_impl_clone_on_copy)]",
    "#![deny(clippy::fallible_impl_from)]",
    "#![deny(clippy::implicit_clone)]",
    "#![deny(clippy::large_stack_arrays)]",
    "#![warn(clippy::manual_ok_or)]",
    "#![deny(clippy::missing_docs_in_private_items)]",
    "#![warn(clippy::needless_borrow)]",
    "#![warn(clippy::needless_pass_by_value)]",
    "#![warn(clippy::option_option)]",
    "#![deny(clippy::print_stderr)]",
    "#![deny(clippy::print_stdout)]",
    "#![warn(clippy::rc_buffer)]",
    "#![deny(clippy::ref_option_ref)]",
    "#![warn(clippy::semicolon_if_nothing_returned)]",
    "#![warn(clippy::trait_duplication_in_bounds)]",
    "#![deny(clippy::unchecked_duration_subtraction)]",
    "#![deny(clippy::unnecessary_wraps)]",
    "#![warn(clippy::unseparated_literal_suffix)]",
    "#![deny(clippy::unwrap_used)]",
    "#![deny(clippy::mod_module_files)]",
    "#![allow(clippy::let_unit_value)] // This can reasonably be done for explicitness",
    "#![allow(clippy::uninlined_format_args)]",
    "#![allow(clippy::significant_drop_in_scrutinee)] // arti/-/merge_requests/588/#note_2812945",
    "#![allow(clippy::result_large_err)] // temporary workaround for arti#587",
    "#![allow(clippy::needless_raw_string_hashes)] // complained-about code is fine, often best",
    "#![allow(clippy::needless_lifetimes)] // See arti#1765",
    "#![allow(mismatched_lifetime_syntaxes)] // temporary workaround for arti#2060",
]

# ---------- list of lints to apply or disapply *in tests* ----------

TEST_LINTS: list[str] = [
    "#![allow(clippy::bool_assert_comparison)]",
    "#![allow(clippy::clone_on_copy)]",
    "#![allow(clippy::dbg_macro)]",
    "#![allow(clippy::mixed_attributes_style)]",
    "#![allow(clippy::print_stderr)]",
    "#![allow(clippy::print_stdout)]",
    "#![allow(clippy::single_char_pattern)]",
    "#![allow(clippy::unwrap_used)]",
    "#![allow(clippy::unchecked_duration_subtraction)]",
    "#![allow(clippy::useless_vec)]",
    "#![allow(clippy::needless_pass_by_value)]",
]

# ---------- list of lints to apply or disapply *in examples* ----------

EXAMPLE_LINTS = [
    "#![allow(unknown_lints)] // @@REMOVE_WHEN(ci_arti_nightly)",
    *TEST_LINTS,
]


# ---------- some notes about lints we might use - NOT USED by any code here ----------

SOON: list[str] = []

WISH_WE_COULD = [
    "#![warn(unused_crate_dependencies)]",
]

DECIDED_NOT = [
    "#![deny(clippy::redundant_pub_crate)]",
    "#![deny(clippy::future_not_send)]",
    "#![deny(clippy::redundant_closure_for_method_calls)]",
    "#![deny(clippy::panic)]",
    "#![deny(clippy::if_then_some_else_none)]",
    "#![deny(clippy::expect_used)]",
    "#![deny(clippy::option_if_let_else)]",
    "#![deny(missing_debug_implementations)]",
    "#![deny(clippy::pub_enum_variant_names)]",
]

# ---------- code for autoprocessing Rust source files ----------

PAT = re.compile(r"^ *#!\[(?:cfg_attr\(.*)?(allow|deny|warn)")

LINT_LISTS = {
    "lint": WANT_LINTS,
    "test lint": TEST_LINTS,
    "example lint": EXAMPLE_LINTS,
}
# The start delimiter is a regular comment.
START_LINE = re.compile(r"^(\s*)// @@ begin (.*) list")

# End delimiter is Rustdoc containing an HTML comment, because rustfmt
# *really really* hates comments that come after things.
# Finishing the automaintained block with just a blank line is too much of a hazard.
# It does end up in the output HTML from Rustdoc, but it is harmless there.
END_LINE = re.compile(r"^\s*//! <!-- @@ end (.*) list")


class ImproperFileError(Exception):
    def __init__(self, lno: int, message: str) -> None:
        self.lno = lno
        self.message = message


def strip_lints_containing(
    lint_lists: dict[str, list[str]], substring: str
) -> dict[str, list[str]]:
    """Return a copy of lint_lists with all entries containing substring removed."""
    return {
        name: [line for line in lines if substring not in line]
        for name, lines in lint_lists.items()
    }


def filter_file(
    lint_lists: dict[str, list[str]], inp: TextIO, outp: TextIO, insist: bool
) -> None:
    in_lint_list: str | None = None
    found_lint_list = False
    lno = 0  # ensure defined even for empty files

    for lno, line in enumerate(inp, start=1):
        if start_match := START_LINE.match(line):
            if in_lint_list:
                raise ImproperFileError(
                    lno, 'found "@@ begin lint list" but inside lint list'
                )
            found_lint_list = True
            indent = start_match.group(1)
            in_lint_list = start_match.group(2)
        elif end_match := END_LINE.match(line):
            if not in_lint_list:
                raise ImproperFileError(
                    lno, 'found "@@ end lint list" but not inside lint list'
                )
            if in_lint_list != end_match.group(1):
                raise ImproperFileError(
                    lno,
                    "found end tag "
                    + end_match.group(1)
                    + " but expected "
                    + in_lint_list,
                )
            try:
                lines = lint_lists[in_lint_list]
            except KeyError as e:
                raise ImproperFileError(
                    lno, "No such lint list as " + in_lint_list
                ) from e
            outp.writelines(indent + lint + "\n" for lint in lines)
            in_lint_list = None
        elif in_lint_list:
            if not PAT.match(line):
                raise ImproperFileError(
                    lno, "entry in lint list does not look like a lint"
                )
            continue
        outp.write(line)
    if in_lint_list:
        raise ImproperFileError(
            lno, 'missing "@@ lint list" delimiter, still in lint list at EOF'
        )
    if insist and not found_lint_list:
        raise ImproperFileError(
            lno, "standard lint list block seems to be missing (wrong delimiters?)"
        )


def process(
    lint_lists: dict[str, list[str]],
    fn: Path,
    *,
    always_insist: bool,
    check: bool,
) -> bool:
    """Process the file named fn, replacing its lint list if needed.

    Return True if the file is OK, False if it produced an error or mismatch.
    """
    insist = (
        always_insist
        or fn.match("crates/*/src/lib.rs")
        or fn.match("crates/*/src/main.rs")
    )

    tmp = fn.parent / (fn.name + ".tmp~")

    try:
        with fn.open("r") as inp, tmp.open("w") as outp:
            filter_file(lint_lists, inp, outp, insist)
    except ImproperFileError as e:
        print(f"{fn}:{e.lno}: {e.message}", file=sys.stderr)
        with suppress(FileNotFoundError):
            tmp.unlink()
        return False

    if check:
        if subprocess.run(["diff", "-u", "--", str(fn), str(tmp)]).returncode != 0:
            return False
    else:
        tmp.replace(fn)

    return True


def main(
    lint_lists: dict[str, list[str]],
    files: list[Path],
    *,
    check: bool,
    ci_nightly: bool,
    ci_stable: bool,
) -> None:
    if not Path("./crates/tor-proto/src/lib.rs").exists():
        print("Run this from the top level of an arti repo.")
        sys.exit(1)

    always_insist = True
    if not files:
        files = list(Path().rglob("*.rs"))
        always_insist = False

    lint_lists = LINT_LISTS

    if ci_nightly:
        lint_lists = strip_lints_containing(
            lint_lists, "@@REMOVE_WHEN(ci_arti_nightly)"
        )
    if ci_stable:
        lint_lists = strip_lints_containing(lint_lists, "@@REMOVE_WHEN(ci_arti_stable)")

    deferred_errors = [
        str(fn)
        for fn in files
        if not process(lint_lists, fn, always_insist=always_insist, check=check)
    ]

    if len(deferred_errors) > 0:
        print(
            "\n"
            + sys.argv[0]
            + ": standard lint block mismatch in the following files:\n  "
            + ", ".join(deferred_errors),
            file=sys.stderr,
        )
        print("Run " + sys.argv[0] + " (possibly after editing it) to fix.")
        sys.exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser("standardise Rust lint blocks")
    parser.add_argument("--check", action="store_true")
    parser.add_argument("--ci-nightly", action="store_true")
    parser.add_argument("--ci-stable", action="store_true")
    parser.add_argument("file", nargs="*", type=Path)
    opts = parser.parse_args()

    main(
        LINT_LISTS,
        opts.file,
        check=opts.check,
        ci_nightly=opts.ci_nightly,
        ci_stable=opts.ci_stable,
    )
